{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Data Structures - Binary Traversal\"\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "    mermaid-format: png\n",
        "    mermaid:\n",
        "      theme: forest\n",
        "#   html: default\n",
        "#   typst: default\n",
        "# jupyter: qmd_Py3111_trial\n",
        "# jupyter: WinPy3.12sys\n",
        "# jupyter: python3\n",
        "jupyter:\n",
        "  kernelspec:\n",
        "    display_name: Python 3.12.0\n",
        "    language: python\n",
        "    name: python3\n",
        "execute:\n",
        "  cache: true\n",
        "  warning: false\n",
        "  fenced: true\n",
        "code-link: true\n",
        "code-block-border-left: true\n",
        "fig-align: center\n",
        "---\n",
        "\n",
        "# __Data Structures__\n",
        "\n",
        "## Most notes will be from\n",
        "- [1. Hands-On Data Structures & Algorithms with Python - Store, Manipulate, & Access Data Effectively(2022, 3E, Packt)](https://www.packtpub.com/en-us/product/hands-on-data-structures-and-algorithms-with-python-9781801073448?type=print&gad_source=1)\n",
        "- [2. Data Structures & Algorithms in Python - Developers Library(2022, 1E, Addison-Wesley)](https://a.co/d/4xThIzs)\n",
        "- [3. A Common-Sense Guide to Data Structures & Algorithms(2020, 2E, Pragmatic)](https://a.co/d/bbxU7kM)\n",
        "\n",
        "## Chapter 6 of 1 - Trees\n",
        "A `Tree` is a hierachical form of data structure. Data structures such as lists, queues, and stacks are linear in that the items are stored in a sequential way. However, a tree is a non-linear data structure, as there is a **parent-child relationship** between the items. The top of the tree's data structure is known as a `root node`. This is the ancestor of all other nodes in the tree.\n",
        "\n",
        "Tree data structures are very important, owing to their use in various applications, such as parsing expressions, efficient searches, and priority queues. Certain document types, such as XML and HTML, can also be represented in a tree.\n",
        "\n",
        "Topics covered:\n",
        "- Terms & definitions of trees\n",
        "- Binary trees and binary search trees\n",
        "- Tree traversal\n",
        "- Binary search trees\n",
        "\n",
        "### Terminology\n",
        "\n",
        "![Typical Tree](./Typical Tree.png)\n",
        "\n",
        "- **Node**: Each circled letter in the image above represents a node. A node is any data structure that stores data.\n",
        "- **Root Node**: First node from which all other nodes in the tree descend from. In other words, a root node is a node that doesnt have a parent node. In every tree, there is always one unique root node. The root node is node $A$ in the above image.\n",
        "- **Subtree**: Tree whose nodes descend from some other tree. For example, in the image above for example, nodes $F$, $K$, and $L$ form a subtree of the original tree.\n",
        "- **Degree**: The total number of children of a given node is called the `degree of the node`. A tree consisting of only one node has a degree of 0. The degree of node $A$ in the preceeding diagram is 2, the degree of node $B$ is 3, the degree of node $C$ is 3 and, the degree of node $G$ is 1.\n",
        "- **Leaf Node**: Leaf nodes dont have any children and are the terminal node of a given tree. The degree of a leaf node is *always* 0. In the preceeding diagram, the nodes $J$, $E$, $K$, $L$, $H$, $M$, and $I$ are all leaf nodes.\n",
        "- **Edge**: The connection between any given two nodes in a tree is called an *edge*. The total number of edges in a given tree will be a maximum of one less than the total nodes in the tree.\n",
        "\n",
        "  <!-- >> $1 - N_{tot}$ -->\n",
        "\n",
        "\n",
        "```{mermaid}\n",
        "graph TB\n",
        "    %% A((1)) --> B((2))\n",
        "    %% A --> C((3))\n",
        "    %% B --> D((4))\n",
        "    %% B --> E((5))\n",
        "    %% B --> F((6))\n",
        "    %% D --> J((10))\n",
        "    %% F --> K((11))\n",
        "    %% F --> L((12))\n",
        "    %% C --> H((7))\n",
        "    %% C --> I((9))\n",
        "    %% C --> G((8))\n",
        "    %% G --> M((13))\n",
        "    A --- B\n",
        "    A --- C\n",
        "    B --- D\n",
        "    B --- E\n",
        "    B --- F\n",
        "    D --- J\n",
        "    F --- K\n",
        "    F --- L\n",
        "    C --- H\n",
        "    G --- M\n",
        "    C --- I\n",
        "    C --- G\n",
        "```\n",
        "\n",
        "\n",
        "- **Parent**: A node that has a subtree is the parent node of that subtree. For example, node $B$ is the parent of nodes $D$, $E$, and $F$, and node $F$ is the parent of nodes $K$ and $L$.\n",
        "- **Child**: This is a node that is descendant from a parent node. For example, nodes $B$ and $C$ are children of parent node $A$, while nodes $H$, $G$, and $I$ are the children of parent node $C$.\n",
        "- **Sibling**: All nodes with the same parent node are siblings. For example, node $B$ is the sibling of node $C$, and, similarly, nodes $D$, $E$, and $F$ are also siblings.\n",
        "- **Level**: The root node of the tree is considered to be at level 0. The children of the root node are considered to be at level 1, and the children of the nodes at level 1 are considered to be at level 2, and so on. For example, in root node $A$ is at level 0, nodes $B$ and $C$ are at level 1, and nodes $D$, $E$, $F$, $H$, $G$, and $I$ are at level 2.\n",
        "- **Height of a tree**: The total number of nodes in the longest path of the tree is the height of the tree. For example, the height of the tree is 4, as the longest paths, A-B-D-J, A-C-G-M, and A-B-F-K, all have a total number of four nodes each.\n",
        "- **Depth**: The depth of a node is the number of edges from the root of the tree to that node.\n",
        "In the preceding tree example, the depth of node $H$ is 2.\n",
        "\n",
        "### Binary Trees\n",
        "A **Binary Tree** is a collection of nodes, where the nodes in the tree can hve zero, one, or two child nodes. A simple binary tree has a maximum of two children, the left and right child.\n",
        "The nodes in a binary tree are organized in a hierarchical manner, and are read from left to right.\n",
        "\n",
        "```{mermaid}\n",
        "graph TB\n",
        "    5 --- 3\n",
        "    5 --- 7\n",
        "    7 --- 6\n",
        "    7 --- 9\n",
        "```\n",
        "\n",
        "A tree is a **Full Binary** tree if all the nodes of the tree have either zero or two children and there is no node that has one child, example:\n",
        "\n",
        "```{mermaid}\n",
        "graph TB\n",
        "    1---2\n",
        "    1---3\n",
        "    2---4\n",
        "    2---5\n",
        "    5---6\n",
        "    5---7\n",
        "```\n",
        "\n",
        "A **Perfect** binary tree has all the nodes in the binary tree filled, and it doesnt have space vacant for any new nodes; if any new nodes are added, they can only be added by increasing the tree's height. The number of nodes in a perfect binary tree is $2^{h+1} - 1$, where $h$ is the height of the tree.\n",
        "\n",
        "```{mermaid}\n",
        "%%| fig-width: 6.5\n",
        "graph TB\n",
        "    1---2\n",
        "    1---3\n",
        "    2---4\n",
        "    2---5\n",
        "    3---6\n",
        "    3---7\n",
        "```\n",
        "\n",
        "A **Complete** binary tree is filled with all possible nodes except with a possible exception at the lowest level of the tree. All nodes are also filled on the left side. The number of nodes in a complete binary tree is $2^h$, where $h$ is the height of the tree.\n",
        "\n",
        "```{mermaid}\n",
        "graph TB\n",
        "    1---2\n",
        "    1---3\n",
        "    2---4\n",
        "    2---5\n",
        "    3---6\n",
        "    3---7\n",
        "    4---8\n",
        "    4---9\n",
        "```\n",
        "\n",
        "A *Balanced* tree.\n",
        "\n",
        "```{mermaid}\n",
        "graph TB;\n",
        "    1 --- 2\n",
        "    1 --- 3\n",
        "    2 --- 4\n",
        "    2 --- 5\n",
        "    3 --- 6\n",
        "    3 --- 7\n",
        "```"
      ],
      "id": "8bc97bc0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class Node:\n",
        "    def __init__(self, data):\n",
        "      self.data = data\n",
        "      self.right_child = None\n",
        "      self.left_child = None\n"
      ],
      "id": "14cd8575",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To better understand this class, this is the type of tree that will be worked with in the code below.\n",
        "\n",
        "```{mermaid}\n",
        "%%| fig-width: 6.5\n",
        "graph TB\n",
        "  (n1) --- n2\n",
        "  (n1) --- n3\n",
        "  n1 --- n3\n",
        "  n2 --- n4\n",
        "```\n",
        "\n",
        "{{< video https://youtu.be/wo9vZccmqwc >}}"
      ],
      "id": "fbb7eb79"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "n1 = Node(\"root node\")\n",
        "n2 = Node(\"left child node\")\n",
        "n3 = Node(\"right child node\")\n",
        "n4 = Node(\"left grandchild node\")\n",
        "\n",
        "n1.left_child = n2\n",
        "n1.right_child = n3\n",
        "n2.left_hild = n4"
      ],
      "id": "db060041",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Tree traversal\n",
        "The method to visit all the nodes in a tree is called **traversal**. There are three types of tree traversal:\n",
        "    - In-order traversal\n",
        "    - Pre-order traversal\n",
        "    - Post-order traversal\n",
        "In the case of a linear data structure, data element traversal is straightforward since all the items are stored in a sequential manner, so each data item is only visited once. Howver, in the case of non-linear data structures, such as trees and graphs, traversal algorithms are important. The traversal algorithms are used to visit all the nodes in the tree, and the order in which the nodes are visited is important.\n",
        "Beginning with the left substree of the binary tree above, we start from the root node, print out the node, and move down to the tree to the next left node. There are multiple ways to process and traverse the tree that depend upon the sequence of visiting the root node, left subtree, or right subtree. Mainly, there are two kinds of approaches, firstly, one in which we start from a node and traverse every available child node, and then continue to traverse to the next sibling. There are three possible variations of this method, namely, **in-order**, **pre-order**, and **post-order**. Another approach to traverse the tree is to start from the root node and then visit all the nodes on each level, and process the nodes level by level."
      ],
      "id": "d25c0ab9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "current = n1\n",
        "while current:\n",
        "    print(current.data)\n",
        "    current = current.left_child"
      ],
      "id": "c442d077",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### In-order traversal"
      ],
      "id": "914beb0e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def inorder(root_node):\n",
        "    current = root_node\n",
        "    if current is None:\n",
        "        return\n",
        "    inorder(current.left_child)\n",
        "    print(current.data)\n",
        "    inorder(current.right_child)\n",
        "\n",
        "inorder(n1)"
      ],
      "id": "e1304252",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Pre-order traversal"
      ],
      "id": "fec3f3a1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def preorder(root_node):\n",
        "    current = root_node\n",
        "    if current is None:\n",
        "        return\n",
        "    print(current.data)\n",
        "    preorder(current.left_child)\n",
        "    preorder(current.right_child)\n",
        "\n",
        "preorder(n1)"
      ],
      "id": "cb92914d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Post-order traversal"
      ],
      "id": "7c918e23"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def postorder(root_node):\n",
        "    current = root_node\n",
        "    if current is None:\n",
        "        return\n",
        "    postorder(current.left_child)\n",
        "    postorder(current.right_child)\n",
        "    print(current.data)\n",
        "\n",
        "postorder(n1)"
      ],
      "id": "d837a57f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Level-order traversal"
      ],
      "id": "07f76cbb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from collections import deque\n",
        "\n",
        "\n",
        "class Node:\n",
        "    def __init__(self, data):\n",
        "        self.data = data\n",
        "        self.right_child = None\n",
        "        self.left_child = None\n",
        "\n",
        "\n",
        "n1 = Node(\"root node\")\n",
        "n2 = Node(\"left child node\")\n",
        "n3 = Node(\"right child node\")\n",
        "n4 = Node(\"left grandchild node\")\n",
        "\n",
        "n1.left_child = n2\n",
        "n1.right_child = n3\n",
        "n2.left_child = n4\n",
        "\n",
        "\n",
        "def lvl_order_traversal(root_node):\n",
        "    list_of_nodes = []\n",
        "    traversal_queue = deque([root_node])\n",
        "    while len(traversal_queue) > 0:\n",
        "        node = traversal_queue.popleft()\n",
        "        list_of_nodes.append(node.data)\n",
        "        if node.left_child:\n",
        "            traversal_queue.append(node.left_child)\n",
        "            if node.right_child:\n",
        "                traversal_queue.append(node.right_child)\n",
        "    return list_of_nodes\n",
        "\n",
        "\n",
        "print(lvl_order_traversal(n1))\n",
        "# ['root node', 'left child node', 'right child node', 'left grandchild node']"
      ],
      "id": "f9f15bab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "If the number of elements in `traversal_queue` is greater than 0, the body of the loop is executed. The node at the front of the queue is popped off and added to the `list_of_nodes` list. The first `if` statement will enqueue the left child node if the node provided with a left node exists. The second `if` statement does the same for the right child node. Further, the `list_of_nodes` list is returned in the last statement.\n",
        "\n",
        "## Important applications of binary trees:\n",
        "1. Binary trees as expression trees are used in compilers.\n",
        "2. It is also used in Huffman coding in data compression.\n",
        "3. Binary search trees are used for efficient searching, insertion, and deletion of a list of items.\n",
        "4. **Priority Queue (PQ)**, which is used for finding and deleting minimum or maximum items in a collection of elements in logarithmic time in the worst case.\n",
        "\n",
        "\n",
        "### Expression Trees"
      ],
      "id": "fca446fe"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3.12.0",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}